abstract type Potential end

@with_kw mutable struct PotentialFields <: DeconflictStrategy
    name::String="PotentialFields"
    interaction_radius::Float64 = 20.0
    agent_max_speed::Float64 = 1.0
    static_potentials::Vector{Potential} = []
    dynamic_potentials::Vector{Potential} = []  # Potentials of moving agents
end

"""
    perform_twist_deconfliction(p::PotentialFields, env, node) -> Twist

Computes a deconflicted twist for an agent within an environment including both
static and dynamic obstacles, utilizing the Potential Fields method. This
approach calculates a desired twist (linear and angular velocity) that guides
the agent towards its goal while avoiding collisions with obstacles and other 
agents.

# Arguments
- `p::PotentialFields`: The Potential Fields deconfliction strategy instance,
which contains parameters such as interaction radius, agent maximum speed, and
lists of static and dynamic potentials.
- `env`: Simulation environment with current state of agents and obstacles.
- `node`: The agent for which the twist is being calculated.

# Returns
- `Twist`: The computed twist that combines linear and angular velocities, 
optimized to achieve goal-oriented movement while avoiding collisions with both
static and dynamic obstacles.
"""
function perform_twist_deconfliction(p::PotentialFields, env, node)
    @unpack sched, scene_tree, agent_policies, cache, dt = env
    agent = entity(node)
    goal = global_transform(goal_config(node))
    mode = :not_set
    # Compute a baseline twist aimed directly at the agent's goal based on the
    # current position and goal configuration.
    twist = compute_twist_from_goal(env, agent, goal, dt)
    # Optionally reduces agent's velocity when near the goal to prevent
    # overcrowding, using proximity to goal and status of the parent build step.
    # Note: sets nominal velocity to zero if close to goal (this is a hack).
    parent_step = get_parent_build_step(sched, node)
    if !(parent_step === nothing)
        countdown = active_build_step_countdown(parent_step.node, env)
        dist_to_goal = norm(goal.translation .- global_transform(agent).translation)
        unit_radius = get_base_geom(entity(node), HypersphereKey()).radius
        if (mode != :EXIT_CIRCLE) && (dist_to_goal < 15 * unit_radius)
            # Ensure the agent doesn't crowd its destination
            if matches_template(TransportUnitGo, node) && countdown >= 1
                twist = Twist(0.0 * twist.vel, twist.ω)
            elseif matches_template(RobotGo, node) && countdown >= 3
                twist = Twist(0.0 * twist.vel, twist.ω)
            end
        end
    end
    policy = agent_policies[node_id(agent)].dispersion_policy
    # Adjust the agent's path to avoid collisions with other agents by
    # dynamically recalculating the goal position considering potential fields
    # generated by other agents and obstacles.
    # Note: for RobotGo node, ensures that parent assembly is "pickup-able".
    ready_for_pickup = cargo_ready_for_pickup(node, env)
    build_step_active = parent_build_step_is_active(node, env)
    update_dist_to_nearest_active_agent!(policy, env)
    update_buffer_radius!(policy, node, build_step_active, ready_for_pickup)

    if !(build_step_active && ready_for_pickup)
        policy.node = node  # update policy
        nominal_twist = twist  # compute target position
        pos = project_to_2d(global_transform(agent).translation)
        va = nominal_twist.vel[1:2]
        target_pos = pos .+ va * dt
        # Blend velocities derived from nominal goal-directed movement and 
        # avoidance of dynamic obstacles, ensuring smooth navigation around
        # obstacles while maintaining progress towards the goal.
        vb = -1.0 * compute_potential_gradient!(policy, env, pos)  # commanded velocity from current position
        vc = -1.0 * compute_potential_gradient!(policy, env, target_pos)  # commanded velocity from current position
        a = 1.0
        b = 1.0
        c = 0.0
        v = (a * va + b * vb + c * vc)
        vel = clip_velocity(v, policy.vmax)
        # Computes a new goal position based on blended velocity, which respects
        # both the agent's original mission and the need for collision avoidance.
        goal_pt = pos + vel * dt
        goal = CoordinateTransformations.Translation(goal_pt..., 0.0) ∘ 
            CoordinateTransformations.LinearMap(goal.linear)
        # Computes final twist based on the recalculated goal, ensuring agent's
        # movement adheres to speed limitations and navigational constraints.
        twist = compute_twist_from_goal(env, agent, goal, dt)  # nominal twist
    else
        !(policy === nothing)
        policy.dist_to_nearest_active_agent = 0.0
    end
    return twist
end

potential(v::Vector, x) = sum(potential(p, x) for p in v)
potential_gradient(v, x) = ForwardDiff.gradient(x -> potential(v, x), x)
potential_gradient(v::Vector, x) = sum(potential_gradient(p, x) for p in v)
(p::Potential)(x) = potential(p, x)

"""
    ConePotential <: Potential

Produces a potential function in the shape of a cone.
"""
mutable struct ConePotential <: Potential
    c::Any  # coefficient
    R::Any  # radius
    x::Any  # center
end

potential(p::ConePotential, x) = p.c * min(p.R, norm(p.x - x))

"""
    HelicalPotential
"""
mutable struct HelicalPotential
    c::Any  # coefficient
    x::Any  # center
    θ::Any  # desired angle
end

function potential(p::HelicalPotential, x)
    ψ = atan(x[2], x[1])
    Δθ = wrap_to_pi(angular_difference(θ, ψ))
    return p.c * Δθ
end

"""
    TentPotential <: Potential

Produces a potential function in the shape of a tent
"""
mutable struct TentPotential <: Potential
    c::Any  # coefficient
    R::Any  # radius
    x::Any  # start
    g::Any  # goal
end

function potential(p::TentPotential, x)
    dx = x - p.x
    v = p.g - p.x
    xp = dot(dx, v) * v / norm(v)^2
    if 0.0 < dot(xp, normalize(v)) < norm(v)
        return p.c * min(p.R, norm(dx - xp))
    else
        return p.c * min(p.R, min(norm(x - p.x), norm(x - (p.g))))
    end
end

mutable struct TransformPotential <: Potential
    p::Any  # potential
    f::Any  # function
end

potential(p::TransformPotential, x) = p.f(potential(p.p, x))

mutable struct GenericPotential <: Potential
    f::Any  # function
end

potential(p::GenericPotential, x) = p.f(x)

mutable struct ScaledPotential
    p::Any  # potential
    c::Any  # scalar
end

potential(p::ScaledPotential, x) = p.c * potential(p.p, x)

"""
    ClippedPotential

Represents a clipped potential function
"""
mutable struct ClippedPotential <: Potential
    p::Any  # potential
    c::Any  # coefficient
    R::Any  # radius
end

potential(p::ClippedPotential, x) = p.c * max(p.R, potential(p.p, x))

"""
    BarrierPotential

Encodes a potential field formed by inverting the squared value of a child
potential plus some minimum denominator value
"""
mutable struct BarrierPotential <: Potential
    p::Any  # potential
    c::Any  # coefficient
    z::Any  # minimum denominator
end

potential(p::BarrierPotential, x) = p.c / (p.z + potential(p.p, x)^2)

"""
    RotationalPotential

Encodes a rotational field
"""
mutable struct RotationalPotential
    p::Any  # potential
    c::Any  # coefficient
    zmax::Any  # maximum magnitude
end

function potential_gradient(p::RotationalPotential, x)
    dx = potential_gradient(p.p, x)
    v = [0.0, 0.0, 1.0]
    dz = cross(v, [dx..., 0.0])[1:2]
    if norm(dz) > p.zmax
        return p.zmax * normalize(dz)
    else
        return dz
    end
end

mutable struct PairwisePotential
    f::Any
    scale::Any
end

(p::PairwisePotential)(x1, x2, r1, r2) = p.f(x1, x2, r1, r2)

"""
    repulsion_potential(x,r,x2,r2;

Combines a cone potential and a 1/||x|| barrier potential for pairwise
repulsion.
"""
function repulsion_potential(
    x,
    r,
    x2,
    r2;
    dr = 2 * default_robot_radius(),
)
    dx = x .- x2
    R = r + r2
    # Cone
    f1 = max(0.0, R + dr - norm(dx))
    # Barrier
    f2 = max(0, 1 / (norm(dx) - dr) - 1 / R)
    return f1 + f2
end

@with_kw mutable struct PotentialFieldController
    agent = nothing
    node = nothing
    agent_radius = 1.0
    vmax = 1.0
    # Used for modifying potentials
    dist_to_nearest_active_agent = Inf  # track distance to closest agent
    max_buffer_radius = 2.5 * agent_radius  # maximum buffer to add for potential
    buffer_radius = max_buffer_radius  # how much buffer to add for potential
    interaction_radius = 20 * ROBOT_RADIUS
    # Potentials between all pairs of robots
    pairwise_potentials = (x, r, xp, rp) -> repulsion_potential(x, r, xp, rp)
    # Environment potentials (may depend on other agent's states)
    static_potentials = (x, r) -> 0.0
end

function dist_to_nearest_active_agent(policy::PotentialFieldController, env::PlannerEnv)
    @unpack scene_tree, sched, cache = env
    agent = policy.agent
    pos = project_to_2d(global_transform(agent).translation)
    shortest_dist = Inf
    id = nothing
    for (other_id, other_p) in env.agent_policies
        other_policy = other_p.dispersion_policy
        if !(other_policy === policy)
            other_node = other_policy.node
            pbs_active = parent_build_step_is_active(node_id(entity(other_node)), env)
            if (pbs_active && cargo_ready_for_pickup(other_node, env))
                other_agent = other_policy.agent
                other_rad = other_policy.agent_radius
                other_pos = project_to_2d(global_transform(other_agent).translation)
                # other_rad = get_radius(get_base_geom(other_agent,HypersphereKey()))
                dist = norm(pos - other_pos) - (other_rad + policy.agent_radius)
                if dist < shortest_dist
                    shortest_dist = min(dist, shortest_dist)
                    id = node_id(other_agent)
                end
            end
        end
    end
    return id, shortest_dist
end

function update_dist_to_nearest_active_agent!(
    policy::PotentialFieldController,
    env::PlannerEnv,
)
    id, dist = dist_to_nearest_active_agent(policy, env)
    policy.dist_to_nearest_active_agent = dist
end

function update_buffer_radius!(
    policy::PotentialFieldController,
    node::Union{RobotGo,TransportUnitGo},
    build_step_active::Bool,
    cargo_ready_for_pickup::Bool,
)
    r_j = min(
        policy.max_buffer_radius,
        policy.agent_radius / policy.dist_to_nearest_active_agent,
    )
    active_agent = (
        (matches_template(TransportUnitGo, node) && build_step_active) || (
            matches_template(RobotGo, node) && build_step_active && cargo_ready_for_pickup
        )
    )
    if active_agent
        r_j = policy.max_buffer_radius
    end
    policy.buffer_radius = r_j
end

function static_potential_gradient(c::PotentialFieldController, pos)
    ForwardDiff.gradient(x -> c.static_potentials(x, c.agent_radius), pos)
end

function pairwise_potential_gradient(
    c::PotentialFieldController,
    pos,
    other_pos,
    other_radius;
    dr = 1.0,
)
    ForwardDiff.gradient(
        x -> c.pairwise_potentials(x, c.agent_radius, other_pos, other_radius, ; dr = dr),
        pos,
    )
end

function clip_velocity(vel, vmax)
    if norm(vel) > vmax
        v = vmax * normalize(vel)
    else
        v = vel
    end
    return v
end

function pairwise_potential_scale(policy::PotentialFieldController, α1, α2)
    if α1 < α2
        return 0.0 # precedence--no push
    elseif α1 == 0
        return α2 / (α1 + min(α2, 0.05))
    else
        return α2 / α1
    end
end

"""
    pairwise_potential_width(policy::PotentialFieldController,α1,α2)

How much extra width to add to pairwise potential.
"""
function pairwise_potential_width(policy::PotentialFieldController, α1, α2)
    if α1 < α2
        return 0.0 # no push
    elseif α1 == 0
        return default_robot_radius()
    else
        return 0.5 * default_robot_radius()
    end
end

function compute_potential_gradient!(policy::PotentialFieldController, env::PlannerEnv, pos)
    @unpack scene_tree, sched = env
    agent = policy.agent
    dp = static_potential_gradient(policy, pos)
    α1 = get_agent_alpha(env.deconfliction_type, agent)
    for other_agent in rvo_active_agents(scene_tree)
        if !(agent === other_agent)
            α2 = get_agent_alpha(env.deconfliction_type, other_agent)
            if α1 <= α2 # can't be pushed by other agent
                continue
            end
            other_policy = env.agent_policies[node_id(other_agent)].dispersion_policy
            other_rad = other_policy.agent_radius
            scale = 1.0
            other_pos = project_to_2d(global_transform(other_agent).translation)
            if norm(pos - other_pos) <= policy.interaction_radius
                dp =
                    dp .+
                    scale * pairwise_potential_gradient(
                        policy,
                        pos,
                        other_pos,
                        other_rad; # + dilate based on priority?
                        dr = other_policy.buffer_radius,
                    )
            end
        end
    end
    return dp
end
function compute_velocity_command!(policy::PotentialFieldController, env::PlannerEnv, pos)
    dp = compute_potential_gradient!(policy::PotentialFieldController, env, pos)
    vel = clip_velocity(-1.0 * dp, policy.vmax)
    return vel
end

@with_kw mutable struct PotentialController
    x = nothing # state
    v = nothing # velocity
    circ_idx = -1      # index of circle that robot may enter
    goal = nothing # goal position
    p = nothing # potential function
    dp = nothing # gradient of potential function
    radius = nothing # radius
    vmax = 1.0
end

ROBOT_RADIUS = 0.5

@with_kw mutable struct GlobalPotentialController
    robot_controllers = Dict()
    goal_potentials = Dict()
    circle_potentials = Dict()
    collision_potentials = Dict()
    path_potentials = Dict()
    INTERACTION_RANGE = 5 * ROBOT_RADIUS
end

function update_potential_controllers!(controller)
    for (k, robot) in controller.robot_controllers
        update_potential_controller!(robot, k, controller)
    end
    controller
end

function update_potential_controller!(robot, i, global_controller)  # i is the robot's index
    potentials = []
    C = global_controller
    # Pull robot toward its goal
    push!(potentials, C.goal_potentials[i])
    # Repel robot from circles in which it does not belong
    if robot.circ_idx > 0
        push!(potentials, C.circle_potentials[robot.circ_idx])
    end
    # Allow higher priority robots to push robot out of the way
    for (k, r) in C.robot_controllers
        p = C.path_potentials[k]
        if !(robot === r) && norm(r.x - robot.x) <= C.INTERACTION_RANGE
            if r.circ_idx < robot.circ_idx  # replace with priority check
                push!(potentials, p)
            end
        end
    end
    # Set potentials
    robot.p = potentials
    # Compute local gradient of potential fields
    robot.dp = potential_gradient(robot.p, robot.x)
    # Set velocity in direction of gradient descent
    vel = -1.0 * robot.dp
    if norm(vel) > robot.vmax
        robot.v = robot.vmax * normalize(vel)
    else
        robot.v = vel
    end
    return robot
end

function update_env_with_deconfliction(p::PotentialFields, scene_tree, env)
    for node in get_nodes(env.sched)
        if matches_template(Union{RobotStart,FormTransportUnit}, node)
            n = entity(node)
            agent_radius = get_radius(get_base_geom(n, HypersphereKey()))
            vmax = get_agent_max_speed(n)
            env.agent_policies[node_id(n)] = ConstructionBots.VelocityController(
                nominal_policy = nothing,
                dispersion_policy = 
                ConstructionBots.PotentialFieldController(
                    agent = n,
                    node = node,
                    agent_radius = agent_radius,
                    vmax = vmax,
                    max_buffer_radius = 2.5 * agent_radius,
                    interaction_radius = 15 * agent_radius,
                    static_potentials = (x, r) -> 0.0,
                    pairwise_potentials = ConstructionBots.repulsion_potential,
                ),
            )
        end
    end
end
